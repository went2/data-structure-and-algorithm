# 队列 Queues

## 1. 概念 Queue as ADT

Queue 是一种列表结构，有前后两个方向，从 queue 中插入数据需要从后方插入，从 queue 中删除数据需要从前方删除。这是一种先进先出的操作方式。

### 1.1 Operations

- EnQueue(x) or Push(x), 如 `void Enqueue(int x);`
- DeQueue() or Pop(), 删除一个元素要返回该元素，如 `int Dequeue();`
- Front() or Peek(), 获取位于队列头部的元素
- IsEmpty()
- IsFull()

这些操作的时间复杂度应为 O(1)


队列的首(rear)和尾(front)的概念是在更基本结构上模拟出来的

### 1.2 使用场景

用于资源共享使用的场景中，资源提供方只能一个个处理请求，所以要把请求放在一个队列结构中，先到的先处理。

比如一个在局域网中打印机，打印机只能一份份打印，同一时间有多份文件发给打印机时，打印机按照收到的先后顺序执行打印任务。

- 打印机队列
- process schedule
- simulating wait

## 2. 队列的实现

队列可用数组或链表来实现一个队列。基本思路是在一个数组或链表的结构上：
	- 增加 front、rear 变量来标识队列的头和尾；
	- 增加基于 front、rear 的队列常用操作



### 2.1 用（环形）数组实现队列

首先对数组做一层抽象：用环形数组来最大化数组空间的利用。

环形数组比一般数组多了一个对**到达索引边界**后的处理：

比如 `int arr[10]`，获取第一个元素用`a[0]`，获取最后一个元素用 `a[9]`，把这个数组变成环形数组，不是说它在内存中存储结构发生变化，而是我们读取它的方式发生变化。

之前读取 `a[10]` 读到的已经不是这个数组内的数据，但在环形数组情况下，希望 `a[10]` 的效果变成 `a[0]`，`a[-1]` 的效果变成 `a[9]`，如何发生这样的改变：

计算索引的方式改变：从 `i+1` 变成 `(i+1)%10`， 从 `i-1` 变成 `(i+10-1)%10`。

用两个变量管理队列的头和尾：`front`、`rear`：

	- 初始化队列时，将`front`、`rear` 设为 `-1`，表示队列为空；
	- EnQueue(x)， `rear = rear + 1; arr[rear] = x`，要先处理队列为空、队列已满这两种边界情况；
	- DeQueue()，`front = front + 1`，要先处理队列为空，队列只有一个值这两个边界情况；
	- IsEmpty(), `return front == -1 && rear == -1`；
	- IsFull(), 环形数组的尾部加1是否等于头部，`return (rear + 1)%(MAX_SIZE) == front`











